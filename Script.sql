SELECT * FROM USER1;


-- 실습하기 2-1

 CREATE TABLE USER2 (
ID VARCHAR2(20) PRIMARY KEY,
NAME VARCHAR2(20),
HP CHAR(13),
AGE NUMBER(2)
);


INSERT INTO USER2 VALUES ('A101', '장거한', '010-1234-1111', 36);
INSERT INTO USER2 VALUES ('A102', '김춘추', '010-1234-2222', 23);
INSERT INTO USER2 VALUES ('A103', '장보고', '010-1234-3333', 32);
INSERT INTO USER2 (id, name, age) VALUES ('A104', '강감찬', 45); --순서대로 맵핑 방식인듯 하다.
INSERT INTO USER2 (id, name, hp) VALUES ('A105', '이순신', '010-1234-5555');


-- 실습 2-2, 고유키 실습


 CREATE TABLE USER3 (
ID VARCHAR2(20) PRIMARY KEY,
NAME VARCHAR2(20),
HP CHAR(13) UNIQUE,
AGE NUMBER(2)
);


INSERT INTO USER3 VALUES ('A101', '장거한', '010-1234-1111', 36);
INSERT INTO USER3 VALUES ('A102', '김춘추', '010-1234-2222', 23);
INSERT INTO USER3 VALUES ('A103', '장보고', '010-1234-3333', 32);
INSERT INTO USER3 (id, name, age) VALUES ('A104', '강감찬', 45); --순서대로 맵핑 방식인듯 하다.  HP없어서 무결성 제약 조건 에러
INSERT INTO USER3 (id, name, hp) VALUES ('A105', '이순신', '010-1234-3333');  -- UNIQUE hp중복 에러


-- 실습 2-3, 외래키 실습

CREATE TABLE PARENT(
	PID  VARCHAR(20) PRIMARY KEY,
	NAME VARCHAR(20), 
	HP 	 CHAR(13) UNIQUE
);


CREATE TABLE CHILD(

	CID VARCHAR2(20) PRIMARY KEY,
	NAME VARCHAR2(20), 
	HP CHAR(13) UNIQUE,
	PARENT VARCHAR2(20),
	FOREIGN KEY (PARENT) REFERENCES PARENT (PID)

);

INSERT INTO PARENT VALUES ('P101', '김서현', '010-1234-1001');
INSERT INTO PARENT VALUES ('P102', '이성계', '010-1234-1002');
INSERT INTO PARENT VALUES ('P103', '신사임당', '010-1234-1003');
INSERT INTO CHILD VALUES ('C101', '김유신', '010-1234-2001', 'P101');
INSERT INTO CHILD VALUES ('C102', '이방우', '010-1234-2002', 'P102');
INSERT INTO CHILD VALUES ('C103', '이방원', '010-1234-2003', 'P102');
INSERT INTO CHILD VALUES ('C104', '이이', '010-1234-2004', 'P103');

-- 실습 2-4, DEFAULT와 NOT NULL실습

CREATE TABLE USER4(
	NAME VARCHAR(20) NOT NULL,
	GENDER CHAR(1) NOT NULL,
	AGE INT DEFAULT 1,
	ADDR VARCHAR(255)
);



-- insert into user4 set('name','age','hp') value('~~',111,'~~') 오라클에서는 이런 set key value 식의 인서트 안됨

INSERT INTO USER4 VALUES ('김유신', 'M', 23, '김해시');
INSERT INTO USER4 VALUES ('김춘추', 'M', 21, '경주시');
INSERT INTO USER4 (NAME, GENDER, ADDR) VALUES ('신사임당', 'F', '강릉시');
INSERT INTO USER4 (NAME, GENDER) VALUES ('이순신', 'M');
INSERT INTO USER4 (NAME, AGE) VALUES ('정약용', 33);





-- 실습 2-5, check 제약조건 실습
-- 애초에 입력 받을때 무결성 검사를 하기 때문에 check 제약 조건을 잘 사용하지 않는다.
 CREATE TABLE USER5 (
NAME VARCHAR2(20) NOT NULL,
GENDER CHAR(1) NOT NULL CHECK(GENDER IN('M', 'F')),
AGE INT DEFAULT 1 CHECK(AGE > 0 AND AGE < 100),
ADDR VARCHAR2(255)
);

INSERT INTO USER5 VALUES ('김유신', 'M', 23, '김해시');
INSERT INTO USER5 VALUES ('김춘추', 'M', 21, '경주시');
INSERT INTO USER5 (NAME, GENDER, ADDR) VALUES ('신사임당', 'F', '강릉시');
INSERT INTO USER5 (NAME, GENDER) VALUES ('이순신', 'M');
INSERT INTO USER5 (NAME, AGE) VALUES ('정약용', 33);


-- 실습 2-6, 고유키 실습




-- 실습 3-2, 인덱스 조회/생성/삭제
-- 현재 사용자 인덱스 조회


SELECT * FROM DICT;

SELECT TABLE_name FROM user_tables;

SELECT  owner, TABLE_name FROM all_tables;


SELECT * FROM user_indexes;


-- 현재 사용자 인덱스 정보 조회
SELECT * FROM user_ind_columns;


-- 인덱스 생성
CREATE INDEX idx_user1_id ON user1 (id);
SELECT * FROM USER_IND_COLUMNS;


-- 인덱스 삭제
DROP INDEX idx_user1_id;
SELECT * FROM USER_IND_COLUMNS;




-- 뷰 생성 권한 할당
GRANT CREATE VIEW TO scott;


CREATE VIEW VW_USER1 AS (SELECT NAME, HP, AGE FROM USER1);
CREATE VIEW VW_USER2_AGE_UNDER30 AS (SELECT * FROM USER2 WHERE AGE < 30);
SELECT * FROM USER_VIEWS;



-- 실습 3-5. sequence

CREATE TABLE USER6(
	SEQ NUMBER PRIMARY KEY,
	NAME VARCHAR(20),
	GENDER CHAR(1),
	AGE NUMBER,
	ADDR VARCHAR(255)

)


-- 실습 3-6 시퀀스 생성
CREATE SEQUENCE SEQ_USER6 INCREMENT BY 1 START WITH 1;

-- 실습 3-7 시퀀스 값 입력
INSERT INTO USER6 VALUES(SEQ_USER6.NEXTVAL,'김유신','M',44,'김해시');
INSERT INTO USER6 VALUES(SEQ_USER6.NEXTVAL,'하후돈','M',66,'쓰촨성');
INSERT INTO USER6 VALUES(SEQ_USER6.NEXTVAL,'오거돈','M',99,'부산시');





-- 날짜: 2023/10/04
-- 이름: 정영재
-- 내용: 3장 SQL 실습 (20P까지)





CREATE  TABLE DEPT(
	DEPTNO NUMBER(2) CONSTRAINT PK_DEPT PRIMARY KEY,
	DNAME VARCHAR2(14),
	LOC VARCHAR2(13)
);



CREATE  TABLE EMP(
	EMPNO NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY,
	ENAME VARCHAR2(10),
	JOB VARCHAR2(9),
	MGR NUMBER(4),
	HIREDATE DATE,
	SAL NUMBER(7,2),
	COMM NUMBER(7,2),
	DEPTNO NUMBER(2) CONSTRAINT FK_DEPTNO REFERENCES DEPT
);



CREATE  TABLE SALGRADE(
	GRADE	NUMBER,
	LOSAL	NUMBER,
	HISAL	NUMBER
);


CREATE  TABLE BONUS(
	ENAME VARCHAR2(10),
	JOB		VARCHAR2(9),
	SAL		NUMBER,
	COMM	NUMBER
);


-- 1-2 실습 테이블 데이터 입력

INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');


INSERT INTO EMP VALUES (7369, 'SMITH', 'CLERK', 7902, '80-12-17', 800, NULL, 20);
INSERT INTO EMP VALUES (7499, 'ALLEN', 'SALESMAN', 7698, '81-02-20',1600,300,30);
INSERT INTO EMP VALUES (7521, 'WARD', 'SALESMAN', 7698, '81-02-22', 1250, 500, 30);



INSERT INTO EMP VALUES (7566, 'JONES', 'MANAGER', 7839, '81-02-04',2975,NULL,20);
INSERT INTO EMP VALUES (7654, 'MARTIN', 'SALESMAN', 7698, '81-09-28',1250,1400,30);
INSERT INTO EMP VALUES (7698, 'BLAKE', 'MANAGER', 7839, '81-05-01',2850,NULL,30);
INSERT INTO EMP VALUES (7782, 'CLARK', 'MANAGER', 7839, '81-06-09',2450,NULL,10);
INSERT INTO EMP VALUES (7788, 'SCOTT', 'ANALYST', 7566, '87-04-19',3000,NULL,20);
INSERT INTO EMP VALUES (7839, 'KING', 'PRESIDENT', NULL, '81-11-17',5000,NULL,10);
INSERT INTO EMP VALUES (7844, 'TURNER', 'SALESMAN', 7698, '81-09-08',1500,0,30);
INSERT INTO EMP VALUES (7876, 'ADAMS','CLERK', 7788, '87-05-23',1100,NULL,20);
INSERT INTO EMP VALUES (7900, 'JAMES', 'CLERK', 7698, '81-12-03', 950,NULL,30);
INSERT INTO EMP VALUES (7902, 'FORD', 'ANALYST', 7566, 
to_date('3-12-1981', 'dd-mm-yyyy'), 3000, NULL, 20);
INSERT INTO EMP VALUES (7934, 'MILLER', 'CLERK', 7782, 
to_date('23-1-1982', 'dd-mm-yyyy'), 1300, NULL, 10);

--급여 등급 테이블 데이터 입력

INSERT INTO SALGRADE VALUES (1, 700, 1200);
INSERT INTO SALGRADE VALUES (2, 1201, 1400);
INSERT INTO SALGRADE VALUES (3, 1401, 2000);
INSERT INTO SALGRADE VALUES (4, 2001, 3000);
INSERT INTO SALGRADE VALUES (5, 3001, 9999);


-- 1-3 기본 데이터 조회

SELECT * FROM EMP;
SELECT EMPNO, ENAME, DEPTNO FROM EMP;



-- 1-4. 기본 데이터 정렬
SELECT * FROM EMP ORDER BY SAL;
SELECT * FROM EMP ORDER BY SAL DESC;
SELECT * FROM EMP ORDER BY DEPTNO ASC, SAL DESC


-- 1-5 중복 제거와 별칭 지정

SELECT DISTINCT DEPTNO FROM EMP;
SELECT DISTINCT JOB, DEPTNO FROM EMP;
SELECT ENAME, SAL, SAL*12+COMM, COMM FROM EMP;
SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP

-- 2-1 다양한 조건으로 데이터 조회


SELECT * FROM EMP WHERE DEPTNO=30;
SELECT * FROM EMP WHERE DEPTNO=30 AND JOB='SALESMAN';
SELECT * FROM EMP WHERE DEPTNO=30 OR JOB='CLERK';

SELECT * FROM EMP WHERE SAL * 12 = 36000;
SELECT * FROM EMP WHERE SAL >= 3000;
SELECT * FROM EMP WHERE SAL != 3000;
SELECT * FROM EMP WHERE SAL <> 3000;   -- <>는 다르다를 의미  같은 의미로 != ,  ^= 이 있다. 셋 모두 같지 않다음을 의미
SELECT * FROM EMP WHERE NOT SAL = 3000;  -- NOT은 조건과 반대되는 데이터를 검색한다. AND OR는 아는바와 같은 의미


SELECT * FROM EMP WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
SELECT * FROM EMP WHERE JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');


SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000;
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;
SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000;


SELECT * FROM EMP WHERE ENAME LIKE 'S%';
SELECT * FROM EMP WHERE ENAME LIKE '_L%';
SELECT * FROM EMP WHERE ENAME LIKE '%AM%';
SELECT * FROM EMP WHERE ENAME NOT LIKE '%AM%';


SELECT * FROM EMP WHERE COMM = NULL;
SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE COMM IS NOT NULL;


-- 2-2 집합 연산자를 이용한 데이터 조회
-- UNION은 두 개 이상의 SELECT문에 사용하는 집합 연산자
-- 만약 앞의 셀렉트 컬럼과 뒤의 셀렉트 컬럼 갯수가 다르면 에러가 난다. eclipse.buildId=unknown SQL Error [1789] [42000]: ORA-01789: 질의 블록은 부정확한 수의 결과 열을 가지고 있습니다.
/*UNION으로 이어진 셀렉트 컬럼은 데이터 유형만 같으면 서로 달라도 셀렉트가 가능하다. 그럴 때 결과 값으로 출력되는 컬럼명은 가장 앞에 입력된 컬럼명이 되며, 값은 UNION을 기준으로 앞의 데이터와 뒤의 데이터가 섞여서 나온다.
다만 데이터의 컬럼은 여전히 앞의 유니온명으로 표기된다. 예를들어 
 SELECT EMPNO, ENAME, SAL, DEPTNO 
FROM EMP 
WHERE DEPTNO = 10
 UNION
 SELECT EMPNO, ENAME, SAL, COMM 
FROM EMP 
와 같이 DEPTNO 와 COMM으로 둘의 셀렉트 하는 컬러이 다르지만 문제없이 실행되며 다만 출력되는 4번째 컬럼의 컬럼며은 DEPTNO이며 값은 첫번째 조건인 DEPTNO 10에 해당하는 값과 두번째 조건에 해당하는 DEPTNO 20에 해당하는
값이 출력되며 20에 해당하는 로우는 COMM값을 DEPTNO컬럼에 출력한다. 쉽게 말해 출력되는 DEPTNO에 유니온기준 첫번째 셀렉트는 DEPTNO컬럼에 DEPTNO값을 두번째 셀렉트는 DEPTNO컬럼에 COMM값을 출력한다.
**/
SELECT * FROM EMP WHERE DEPTNO = 10;
SELECT * FROM EMP;

 SELECT EMPNO, ENAME, SAL, DEPTNO 
FROM EMP 
WHERE DEPTNO = 10
 UNION
 SELECT EMPNO, ENAME, SAL, COMM 
FROM EMP 
WHERE DEPTNO = 20;